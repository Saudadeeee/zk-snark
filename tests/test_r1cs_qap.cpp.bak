#include "zkmini/.r1cs.hpp"
#include "zkmini/.qap.hpp"
#include "examples/ab_circuit.hpp"
#include "zkmini/.utils.hpp"
#include <iostream>
#include <cassert>

using namespace zkmini;
using namespace zkmini::examples;

void test_r1cs_basic() {
    std::cout << "Testing R1CS basic functionality..." << std::endl;
    
    // Create simple R1CS: a * b = c
    R1CS r1cs = ABCircuit::create_r1cs();
    
    assert(r1cs.num_variables == 4);
    assert(r1cs.num_public == 1);
    assert(r1cs.num_private == 2);
    assert(r1cs.num_constraints == 1);
    
    // Test valid witness
    Fr a(3), b(4), c(12);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    bool satisfied = r1cs.is_satisfied(public_inputs, private_inputs);
    // TODO: Enable when field arithmetic is implemented
    // assert(satisfied);
    
    // Test invalid witness
    Fr wrong_c(13);
    std::vector<Fr> wrong_public = {wrong_c};
    bool not_satisfied = r1cs.is_satisfied(wrong_public, private_inputs);
    // assert(!not_satisfied);
    
    std::cout << "R1CS basic test passed!" << std::endl;
}

void test_r1cs_assignment_generation() {
    std::cout << "Testing R1CS assignment generation..." << std::endl;
    
    R1CS r1cs = ABCircuit::create_r1cs();
    
    Fr a(5), b(7), c(35);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    std::vector<Fr> full_assignment = r1cs.generate_full_assignment(public_inputs, private_inputs);
    
    // Should be [1, c, a, b] = [1, 35, 5, 7]
    assert(full_assignment.size() == 4);
    assert(full_assignment[0] == Fr(1));  // Constant 1
    assert(full_assignment[1] == c);      // Public input
    assert(full_assignment[2] == a);      // Private input
    assert(full_assignment[3] == b);      // Private input
    
    std::cout << "R1CS assignment generation test passed!" << std::endl;
}

void test_qap_conversion() {
    std::cout << "Testing R1CS to QAP conversion..." << std::endl;
    
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    
    assert(qap.num_variables == r1cs.num_variables);
    assert(qap.num_public == r1cs.num_public);
    assert(qap.degree == r1cs.num_constraints);
    
    // Should have Lagrange polynomials for each variable
    assert(qap.A.size() == qap.num_variables);
    assert(qap.B.size() == qap.num_variables);
    assert(qap.C.size() == qap.num_variables);
    
    // Domain should have the right size
    assert(qap.domain.size() == qap.degree);
    
    std::cout << "QAP conversion test passed!" << std::endl;
}

void test_qap_evaluation() {
    std::cout << "Testing QAP evaluation..." << std::endl;
    
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    
    Fr a(6), b(8), c(48);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    // Evaluate QAP at a point in the domain
    if (!qap.domain.empty()) {
        Fr eval_point = qap.domain[0];
        auto eval = qap.evaluate_at(eval_point, public_inputs, private_inputs);
        
        // At domain points, should satisfy A(r) * B(r) = C(r)
        // TODO: Enable when polynomial arithmetic is implemented
        // Fr product = eval.A_val * eval.B_val;
        // assert(product == eval.C_val);
    }
    
    std::cout << "QAP evaluation test passed!" << std::endl;
}

void test_qap_h_polynomial() {
    std::cout << "Testing QAP H polynomial..." << std::endl;
    
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    
    Fr a(9), b(11), c(99);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    // Compute H polynomial
    Polynomial H = qap.compute_h_polynomial(public_inputs, private_inputs);
    
    // H polynomial degree should be reasonable
    assert(H.degree() < qap.degree + qap.num_variables);
    
    std::cout << "QAP H polynomial test passed!" << std::endl;
}

void test_qap_satisfiability() {
    std::cout << "Testing QAP satisfiability..." << std::endl;
    
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    
    Fr a(2), b(13), c(26);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    // Valid witness should satisfy QAP
    bool qap_satisfied = qap.is_satisfied(public_inputs, private_inputs);
    // TODO: Enable when polynomial operations are implemented
    // assert(qap_satisfied);
    
    // Should also satisfy original R1CS
    bool r1cs_satisfied = r1cs.is_satisfied(public_inputs, private_inputs);
    // assert(r1cs_satisfied);
    
    std::cout << "QAP satisfiability test passed!" << std::endl;
}

void test_quadratic_circuit() {
    std::cout << "Testing quadratic circuit..." << std::endl;
    
    R1CS r1cs = QuadraticCircuit::create_r1cs();
    
    assert(r1cs.num_variables == 4);
    assert(r1cs.num_public == 1);
    assert(r1cs.num_constraints == 2);
    
    // Test with x = 5: x^2 + x + 5 = 25 + 5 + 5 = 35
    Fr x(5);
    auto [public_inputs, private_inputs] = QuadraticCircuit::create_witness(x);
    
    bool satisfied = r1cs.is_satisfied(public_inputs, private_inputs);
    // TODO: Enable when field arithmetic is implemented
    // assert(satisfied);
    
    // Convert to QAP
    QAP qap = QAP::from_r1cs(r1cs);
    bool qap_satisfied = qap.is_satisfied(public_inputs, private_inputs);
    // assert(qap_satisfied);
    
    std::cout << "Quadratic circuit test passed!" << std::endl;
}

int main() {
    try {
        std::cout << "=== R1CS and QAP Tests ===" << std::endl;
        
        test_r1cs_basic();
        test_r1cs_assignment_generation();
        test_qap_conversion();
        test_qap_evaluation();
        test_qap_h_polynomial();
        test_qap_satisfiability();
        test_quadratic_circuit();
        
        std::cout << "All R1CS and QAP tests passed!" << std::endl;
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Test failed: " << e.what() << std::endl;
        return 1;
    }
}