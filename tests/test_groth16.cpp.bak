#include "zkmini/.groth16.hpp"
#include "examples/ab_circuit.hpp"
#include "zkmini/.utils.hpp"
#include <iostream>
#include <cassert>

using namespace zkmini;
using namespace zkmini::examples;

void test_proof_serialization() {
    std::cout << "Testing proof serialization..." << std::endl;
    
    // Create a dummy proof
    G1 A = G1::generator();
    G2 B = G2::generator();
    G1 C = G1::generator() * Fr(2);
    
    Proof original_proof(A, B, C);
    
    // Serialize and deserialize
    std::vector<uint8_t> serialized = original_proof.serialize();
    Proof deserialized_proof = Proof::deserialize(serialized);
    
    // TODO: Enable when proof serialization is implemented
    // assert(original_proof.A == deserialized_proof.A);
    // assert(original_proof.B == deserialized_proof.B);
    // assert(original_proof.C == deserialized_proof.C);
    
    std::cout << "Proof serialization test passed!" << std::endl;
}

void test_keys_serialization() {
    std::cout << "Testing keys serialization..." << std::endl;
    
    // Create dummy proving key
    ProvingKey pk;
    pk.alpha_g1 = G1::generator();
    pk.beta_g1 = G1::generator() * Fr(2);
    pk.num_variables = 4;
    pk.num_public = 1;
    
    // Serialize and deserialize
    std::vector<uint8_t> pk_serialized = pk.serialize();
    ProvingKey pk_deserialized = ProvingKey::deserialize(pk_serialized);
    
    // TODO: Enable when key serialization is implemented
    // assert(pk.num_variables == pk_deserialized.num_variables);
    // assert(pk.num_public == pk_deserialized.num_public);
    
    // Test verifying key
    VerifyingKey vk;
    vk.alpha_g1 = G1::generator();
    vk.num_public = 1;
    
    std::vector<uint8_t> vk_serialized = vk.serialize();
    VerifyingKey vk_deserialized = VerifyingKey::deserialize(vk_serialized);
    
    // assert(vk.num_public == vk_deserialized.num_public);
    
    std::cout << "Keys serialization test passed!" << std::endl;
}

void test_groth16_setup() {
    std::cout << "Testing Groth16 setup..." << std::endl;
    
    // Use simple AB circuit
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    
    // Run setup
    CRS crs = Groth16::setup(qap);
    
    // Check that keys are properly initialized
    assert(crs.pk.num_variables == qap.num_variables);
    assert(crs.pk.num_public == qap.num_public);
    assert(crs.vk.num_public == qap.num_public);
    
    // Keys should have reasonable sizes
    // TODO: Enable when setup is fully implemented
    // assert(crs.pk.A_g1.size() == qap.num_variables);
    // assert(crs.pk.B_g1.size() == qap.num_variables);
    // assert(crs.vk.gamma_abc_g1.size() == qap.num_public + 1);
    
    std::cout << "Groth16 setup test passed!" << std::endl;
}

void test_groth16_prove() {
    std::cout << "Testing Groth16 prove..." << std::endl;
    
    // Setup circuit
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    CRS crs = Groth16::setup(qap);
    
    // Create witness
    Fr a(7), b(9), c(63);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    // Verify witness satisfies R1CS first
    assert(r1cs.is_satisfied(public_inputs, private_inputs));
    
    // Generate proof
    Proof proof = Groth16::prove(crs.pk, qap, public_inputs, private_inputs);
    
    // Proof should be non-trivial
    assert(!proof.A.is_zero());
    assert(!proof.B.is_zero());
    assert(!proof.C.is_zero());
    
    std::cout << "Groth16 prove test passed!" << std::endl;
}

void test_groth16_verify() {
    std::cout << "Testing Groth16 verify..." << std::endl;
    
    // Setup circuit
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    CRS crs = Groth16::setup(qap);
    
    // Create witness and proof
    Fr a(4), b(13), c(52);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    Proof proof = Groth16::prove(crs.pk, qap, public_inputs, private_inputs);
    
    // Verify proof with correct public inputs
    bool valid = Groth16::verify(crs.vk, public_inputs, proof);
    // TODO: Enable when verify is fully implemented
    // assert(valid);
    
    // Verify should fail with wrong public inputs
    std::vector<Fr> wrong_public = {Fr(999)};
    bool invalid = Groth16::verify(crs.vk, wrong_public, proof);
    // assert(!invalid);
    
    std::cout << "Groth16 verify test passed!" << std::endl;
}

void test_groth16_end_to_end() {
    std::cout << "Testing Groth16 end-to-end..." << std::endl;
    
    // Use the quadratic circuit for more complex test
    R1CS r1cs = QuadraticCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    
    // Create witness: x = 10, so y = 100 + 10 + 5 = 115
    Fr x(10);
    auto [public_inputs, private_inputs] = QuadraticCircuit::create_witness(x);
    
    // Run end-to-end test
    bool success = Groth16::test_circuit(qap, public_inputs, private_inputs);
    // TODO: Enable when Groth16 is fully implemented
    // assert(success);
    
    std::cout << "Groth16 end-to-end test passed!" << std::endl;
}

void test_proof_soundness() {
    std::cout << "Testing proof soundness..." << std::endl;
    
    // Setup
    R1CS r1cs = ABCircuit::create_r1cs();
    QAP qap = QAP::from_r1cs(r1cs);
    CRS crs = Groth16::setup(qap);
    
    // Valid witness
    Fr a(5), b(6), c(30);
    std::vector<Fr> public_inputs = {c};
    std::vector<Fr> private_inputs = {a, b};
    
    Proof valid_proof = Groth16::prove(crs.pk, qap, public_inputs, private_inputs);
    
    // Try to verify with different public input (should fail)
    std::vector<Fr> different_public = {Fr(31)};
    bool should_fail = Groth16::verify(crs.vk, different_public, valid_proof);
    // TODO: Enable when verification is implemented
    // assert(!should_fail);
    
    std::cout << "Proof soundness test passed!" << std::endl;
}

int main() {
    try {
        std::cout << "=== Groth16 Tests ===" << std::endl;
        
        test_proof_serialization();
        test_keys_serialization();
        test_groth16_setup();
        test_groth16_prove();
        test_groth16_verify();
        test_groth16_end_to_end();
        test_proof_soundness();
        
        std::cout << "All Groth16 tests passed!" << std::endl;
        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Test failed: " << e.what() << std::endl;
        return 1;
    }
}