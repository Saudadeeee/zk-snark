# ZKMini Benchmarks\n\nBenchmarking suite for performance analysis of cryptographic operations.\n\n## Running Benchmarks\n\n```bash\ncd build\nmake bench\n./benchmarks/bench_all\n```\n\n## Benchmark Categories\n\n### 1. Field Arithmetic (`bench_field.cpp`)\n- Modular addition/subtraction\n- Montgomery multiplication\n- Modular inversion\n- Exponentiation\n\n### 2. Elliptic Curves (`bench_ec.cpp`)\n- Point addition/doubling\n- Scalar multiplication\n- Multi-scalar multiplication (MSM)\n- Batch normalization\n\n### 3. Pairing (`bench_pairing.cpp`)\n- Miller loop\n- Final exponentiation\n- Multi-pairing\n- Pairing check\n\n### 4. Polynomials (`bench_poly.cpp`)\n- FFT/iFFT operations\n- Polynomial multiplication\n- Evaluation/interpolation\n- Lagrange basis\n\n### 5. Protocol (`bench_groth16.cpp`)\n- Trusted setup\n- Proof generation\n- Verification\n- End-to-end circuits\n\n## Expected Performance\n\n### BN254 Operations (Intel i7-10700K)\n```\nField multiplication:     ~50 ns\nG1 scalar multiplication: ~80 μs\nG2 scalar multiplication: ~200 μs\nPairing operation:        ~1.2 ms\nMSM (2^16 points):       ~45 ms\nGroth16 setup (2^16):    ~12 s\nGroth16 prove (2^16):    ~8 s\nGroth16 verify:          ~3 ms\n```\n\n### Memory Usage\n```\nG1 point:        96 bytes (uncompressed)\nG2 point:        192 bytes (uncompressed)\nFr element:      32 bytes\nFq12 element:    384 bytes\nGroth16 proof:   256 bytes\n```\n\n## Optimization Targets\n\n1. **MSM**: Use Pippenger's algorithm with optimal window size\n2. **Pairing**: Implement lazy reduction and sparse arithmetic\n3. **FFT**: Radix-2 Cooley-Tukey with bit-reversal optimization\n4. **Memory**: Minimize allocations in hot paths\n\n## Platform Notes\n\n### x86_64\n- Uses AVX2 instructions for field arithmetic\n- 64-bit multiplication with MULX/ADCX/ADOX\n- Cache-friendly MSM algorithms\n\n### ARM64\n- Alternative field arithmetic implementation\n- NEON vectorization where applicable\n- Different optimal window sizes\n\n### WASM\n- JavaScript BigInt fallback\n- Reduced precision optimizations\n- Worker thread parallelization